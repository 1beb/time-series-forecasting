---
title: "Tidy Time Series & Forecasting in R"
date: "robjhyndman.com/workshop2020"
author: "4. Transformations"
toc: true
output:
  binb::monash:
    colortheme: monashwhite
    keep_tex: yes
    fig_width: 7
    fig_height: 3.5
    includes:
      in_header: header.tex
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(
  echo = TRUE, message = FALSE, warning = FALSE, cache = TRUE,
  dev.args = list(pointsize = 11)
)
options(digits = 3, width = 60)
library(fpp3)
library(purrr)
```

# Calendar adjustments

## Calendar adjustments
\fontsize{9}{9}\sf

```{r, fig.height=3}
as_tsibble(fma::milk) %>%
  rename(total = value) %>%
  mutate(daily_ave = total / days_in_month(as_date(index))) %>%
  gather(key="Series", value="Milk", factor_key=TRUE) %>%
  ggplot(aes(x=index, y=Milk)) + geom_line() + 
    facet_grid(Series ~ ., scales='free') + xlab("Year") +
    ylab("Pounds") +  ggtitle("Milk production per cow")
```

# Per capita adjustments

## Per capita adjustments
\fontsize{13}{14}\sf

```{r gdp-per-capita}
global_economy %>%
  filter(Country == "Australia") %>%
  autoplot(GDP)
```

## Per capita adjustments
\fontsize{13}{14}\sf

```{r gdp-per-capita2}
global_economy %>%
  filter(Country == "Australia") %>%
  autoplot(GDP / Population)
```

# Inflation adjustments 

## Inflation adjustments
\fontsize{10}{10}\sf

```{r, eval=FALSE}
print_retail <- aus_retail %>%
  filter(Industry == "Newspaper and book retailing") %>%
  group_by(Industry) %>%
  index_by(Year = year(Month)) %>%
  summarise(Turnover = sum(Turnover))
aus_economy <- filter(global_economy, Code == "AUS")
print_retail %>%
  left_join(aus_economy, by = "Year") %>%
  mutate(Adj_turnover = Turnover / CPI) %>%
  gather("Type", "Turnover", Turnover, Adj_turnover, 
         factor_key = TRUE) %>%
  ggplot(aes(x = Year, y = Turnover)) +
    geom_line() +
    facet_grid(vars(Type), scales = "free_y") +
    xlab("Years") + ylab(NULL) +
    ggtitle("Turnover: Australian print media industry")
```


## Inflation adjustments
\fontsize{10}{10}\sf

```{r, message=FALSE, warning=FALSE, echo=FALSE, fig.height=5}
print_retail <- aus_retail %>%
  filter(Industry == "Newspaper and book retailing") %>%
  group_by(Industry) %>%
  index_by(Year = year(Month)) %>%
  summarise(Turnover = sum(Turnover))
aus_economy <- filter(global_economy, Code == "AUS")
print_retail %>%
  left_join(aus_economy, by = "Year") %>%
  mutate(Adj_turnover = Turnover / CPI) %>%
  gather("Type", "Turnover", Turnover, Adj_turnover, 
         factor_key = TRUE) %>%
  ggplot(aes(x = Year, y = Turnover)) +
    geom_line() +
    facet_grid(vars(Type), scales = "free_y") +
    xlab("Years") + ylab(NULL) +
    ggtitle("Turnover: Australian print media industry")
```

# Mathematical transformations

## Variance stabilization

\fontsize{13}{15}\sf

If the data show different variation at different levels of the series, then a transformation can be useful.
\pause

Denote original observations as $y_1,\dots,y_n$ and transformed
observations as $w_1, \dots, w_n$.
\pause

\begin{block}{\footnotesize Mathematical transformations for stabilizing
variation}
\begin{tabular}{llc}
Square root & $w_t = \sqrt{y_t}$ & $\downarrow$ \\[0.2cm]
Cube root & $w_t = \sqrt[3]{y_t}$ & Increasing \\[0.2cm]
Logarithm & $w_t = \log(y_t)$  & strength
\end{tabular}
\end{block}
\pause

Logarithms, in particular, are useful because they are more interpretable: changes in a log value are **relative (percent) changes on the original scale**.

## Variance stabilization

```{r food, echo=TRUE}
food <- aus_retail %>%
  filter(Industry == "Food retailing") %>%
  summarise(Turnover = sum(Turnover))
```

```{r food-plot, echo = FALSE, fig.height=3.4}
food %>% autoplot(Turnover) +
  labs(y = "Turnover ($AUD)")
```

## Variance stabilization

```{r food-sqrt1, echo=TRUE, fig.height=4}
food %>% autoplot(sqrt(Turnover)) +
  labs(y = "Square root turnover")
```

## Variance stabilization

```{r food-cbrt, echo=TRUE, fig.height=4}
food %>% autoplot(Turnover^(1/3)) +
  labs(y = "Cube root turnover")
```

## Variance stabilization

```{r food-log, echo=TRUE, fig.height=4}
food %>% autoplot(log(Turnover)) +
  labs(y = "Log turnover")
```

## Variance stabilization

```{r food-inverse, echo=TRUE, fig.height=4}
food %>% autoplot(-1/Turnover) +
  labs(y = "Inverse turnover")
```

## Box-Cox transformations

Each of these transformations is close to a member of the
family of \textbf{Box-Cox transformations}:
$$w_t = \left\{\begin{array}{ll}
        \log(y_t),      & \quad \lambda = 0; \\
        (y_t^\lambda-1)/\lambda ,         & \quad \lambda \ne 0.
\end{array}\right.
$$\pause

* $\lambda=1$: (No substantive transformation)
* $\lambda=\frac12$: (Square root plus linear transformation)
* $\lambda=0$: (Natural logarithm)
* $\lambda=-1$: (Inverse plus 1)

## Box-Cox transformations

```{r food-anim, cache=TRUE, echo=FALSE, fig.show='animate', interval=1/10, message=FALSE, fig.height=5, fig.width=8, aniopts='controls,buttonsize=0.3cm,width=11.5cm'}
library(rlang)
library(gganimate)
library(latex2exp)
food %>%
  mutate(!!!set_names(map(seq(0,1,0.01), ~ expr(fabletools::box_cox(Turnover, !!.x))), seq(0,1,0.01))) %>%
  gather(lambda, Turnover) %>%
  mutate(lambda = as.numeric(lambda)) %>%
  ggplot(aes(x = Month, y = Turnover)) +
  geom_line() +
  transition_states(1 - lambda, state_length = 0) +
  view_follow() +
  ggtitle("Box-Cox transformed food retailing turnover (lambda = {format(1 - as.numeric(closest_state), digits = 2)})")
```

## Box-Cox transformations
\fontsize{13}{14}\sf

```{r food-bc, echo=TRUE,fig.height=4}
food %>% autoplot(box_cox(Turnover, 1/3)) +
  labs(y = "Box-Cox transformed turnover")
```

## Box-Cox transformations

* $y_t^\lambda$ for $\lambda$ close to zero behaves like logs.
* If some $y_t=0$, then must have $\lambda>0$
* if some $y_t<0$, no power transformation is possible unless all $y_t$ adjusted by \textbf{adding a constant to all values}.
* Simple values of $\lambda$ are easier to explain.
* Results are  relatively insensitive to  $\lambda$.
* Often no transformation ($\lambda=1$) needed.
* Transformation can have very large effect on PI.
* Choosing $\lambda=0$ is a simple way to force forecasts to be positive

## Box-Cox transformations

\fontsize{13}{15}\sf


```{r food-lambda, echo=TRUE}
food %>%
  features(Turnover, features = guerrero)
```

\pause

* This attempts to balance the seasonal fluctuations and random variation across the series.
* Always check the results.
* A low value of $\lambda$ can give extremely large prediction intervals.

## Back-transformation

We must reverse the transformation (or \textit{back-transform}) to obtain
forecasts on the original scale. The reverse Box-Cox transformations are given
by
$$ y_t = \left\{\begin{array}{ll}
        \exp(w_t),      & \quad \lambda = 0; \\
        (\lambda W_t+1)^{1/\lambda} ,   & \quad \lambda \ne 0.
\end{array}\right.$$

## Lab Session
\fontsize{13}{14}\sf

1. For the following series, find an appropriate Box-Cox transformation in order to stabilise the variance.

    * United States GDP from `global_economy`
    * Slaughter of Victorian “Bulls, bullocks and steers” in `aus_livestock`
    * Gas production from `aus_production`
  
2. Why is a Box-Cox transformation unhelpful for the `expsmooth::cangas` data?

3. For each of the following series, make a graph of the data. If transforming seems appropriate, do so and describe the effect. Tobacco from `aus_production`, Economy class passengers between Melbourne and Sydney from `ansett`, and Victorian Electricity Demand from `vic_elec`.


